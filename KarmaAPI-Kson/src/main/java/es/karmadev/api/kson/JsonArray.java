package es.karmadev.api.kson;

import es.karmadev.api.kson.object.SimpleArray;

import java.util.Collection;

/**
 * Represents a json array. Similar
 * as {@link JsonObject} this object is
 * similar to a map, with the difference
 * the value is represented in multiple values,
 * instead of a single one.
 */
@SuppressWarnings("unused")
public interface JsonArray extends JsonInstance, Iterable<JsonInstance> {

    /**
     * Create a new json array
     *
     * @return the array
     */
    static JsonArray newArray() {
        return newArray("", '.');
    }

    /**
     * Create a new json array
     *
     * @param path the array path
     * @return the new array
     */
    static JsonArray newArray(final String path) {
        return newArray(path, '.');
    }

    /**
     * Create a new json array
     *
     * @param pathSeparator the path separator
     * @return the new array
     */
    static JsonArray newArray(final char pathSeparator) {
        return newArray("", '.');
    }

    /**
     * Create a new json array
     *
     * @param path the array path
     * @param pathSeparator the array path separator
     * @return the new array
     */
    static JsonArray newArray(final String path, final char pathSeparator) {
        return new SimpleArray(path, pathSeparator);
    }

    /**
     * Get all the array elements
     *
     * @return the array elements
     */
    Collection<JsonInstance> getElements();

    /**
     * Get the array size
     *
     * @return the array size
     */
    int size();

    /**
     * Get if the array contains the string
     * element. Please note the behaviour of
     * this method may be different between array
     * implementations, some implementations may
     * consider to return false if the {@link JsonNative}
     * generated by this method is not the exact same
     * instance as the one stored internally by the array
     *
     * @param string the string to check with
     * @return true if the array contains an element with
     * the same string value.
     */
    default boolean contains(final String string) {
        JsonNative jsonNat = JsonNative.forSequence(string);
        return contains(jsonNat);
    }

    /**
     * Get if the array contains the number
     * element. Please note the behaviour of
     * this method might be unstable, because of
     * number conversions, it's highly recommended
     * to use generated {@link JsonNative} instances
     * for this instead.
     * Please note the behaviour of
     * this method may be different between array
     * implementations, some implementations may
     * consider to return false if the {@link JsonNative}
     * generated by this method is not the exact same
     * instance as the one stored internally by the array
     *
     * @param number the number to check with
     * @return if the array contains an element with
     * the same number value
     */
    default boolean contains(final Number number) {
        JsonNative jsonNat = JsonNative.forNumber(number);
        return contains(jsonNat);
    }

    /**
     * Get if the array contains the boolean
     * element.
     * Please note the behaviour of
     * this method may be different between array
     * implementations, some implementations may
     * consider to return false if the {@link JsonNative}
     * generated by this method is not the exact same
     * instance as the one stored internally by the array
     *
     * @param bool the boolean to check with
     * @return if the array contains an element with
     * the same boolean
     */
    default boolean contains(final boolean bool) {
        JsonNative jsonNat = JsonNative.forBoolean(bool);
        return contains(jsonNat);
    }

    /**
     * Get if the array contains the element.
     * Take in mind that, in case of
     * {@link JsonObject object} checks, this method will
     * check that all the keys matches the array object key
     * values, including child elements, which can lead to high
     * computing usage. We instead recommend to iterate through
     * the elements and use a schema validator on the element
     * to validate that the element is the one you are expecting
     *
     * @param element the element to check with
     * @return if the array contains an element with
     * the same values
     */
    boolean contains(final JsonInstance element);

    /**
     * Get an instance by its index on the
     * array. The index is nothing but the
     * position on the array of the element.
     *
     * @param index the element index
     * @return the element on the specified index
     * @throws IndexOutOfBoundsException if the index
     * is out of bounds of the array
     */
    JsonInstance get(final int index) throws IndexOutOfBoundsException;

    /**
     * Set the instance at the specified array
     * position
     *
     * @param index the index to modify
     * @param newInstance the new value
     * @return if the operation was successful
     * @throws IndexOutOfBoundsException if the index
     * is out of bounds of the array
     */
    boolean set(final int index, final JsonInstance newInstance) throws IndexOutOfBoundsException;

    /**
     * Remove an element on the specified
     * array position
     *
     * @param index the array position
     * @return if the operation was successful
     * @throws IndexOutOfBoundsException if the index
     * is out of bounds of the array
     */
    boolean remove(final int index) throws IndexOutOfBoundsException;

    /**
     * remove an element from the array
     *
     * @param instance the element to remove
     * @return if the operation was successful
     */
    boolean remove(final JsonInstance instance);

    /**
     * Add all the elements from the
     * other array into this element
     *
     * @param other the other array
     * @param unique add only if the current
     *               array does not contain the
     *               element
     * @return if the operation was successful
     */
    default boolean addAll(final JsonArray other, final boolean unique) {
        boolean changes = false;
        for (JsonInstance instance : other) {
            if (unique) {
                if (contains(instance)) continue;
            }

            if (add(instance))
                changes = true;
        }

        return changes;
    }

    /**
     * Add an instance to the array
     *
     * @param instance the instance to add
     * @return if the operation was successful
     */
    boolean add(final JsonInstance instance);

    /**
     * Add the element to the array
     *
     * @param sequence the sequence to add
     * @return if the operation was successful
     */
    default boolean add(final CharSequence sequence) {
        JsonNative jsonNat = JsonNative.forSequence(sequence);
        if (jsonNat.isNull()) return false;

        return add(jsonNat);
    }

    /**
     * Add the element to the array
     *
     * @param number the number to add
     * @return if the operation was successful
     */
    default boolean add(final Number number) {
        JsonNative jsonNat = JsonNative.forNumber(number);
        if (jsonNat.isNull()) return false;

        return add(jsonNat);
    }

    /**
     * Add the element to the array
     *
     * @param bool the boolean to add
     * @return if the operation was successful
     */
    default boolean add(final Boolean bool) {
        JsonNative jsonNat = JsonNative.forBoolean(bool);
        if (jsonNat.isNull()) return false;

        return add(jsonNat);
    }
}
